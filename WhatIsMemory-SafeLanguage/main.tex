
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

% Define basic Rust syntax highlighting for listings
\lstdefinelanguage{Rust}{%
  morekeywords={let,fn,mut,drop,Box},%
  sensitive=true,%
  morecomment=[l]{//},%
  morecomment=[s]{/*}{*/},%
  morestring=[b]"%
}

\geometry{margin=1in}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    frame=single,
    breaklines=true
}

\title{Memory-Safe Programming Languages:\\A Focus on Rust}
\author{Larson Carter}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
Memory-safety vulnerabilities remain a leading cause of software
exploits. This paper introduces the core principles of memory-safe
languages and explains how Rust's ownership and borrowing rules
provide compile-time guarantees that prevent buffer overflows,
use-after-free errors, and data races. We contrast Rust's approach with
manual memory management in C/C++ and with the garbage collectors used
by Java and Go. Real-world deployments and formal results demonstrate
that Rust can deliver C-like performance while eliminating broad
classes of security issues. We conclude with discussion of adoption
trends and remaining challenges on the path toward a predominantly
memory-safe software ecosystem.
\end{abstract}
\tableofcontents
\newpage

\section{Introduction: Memory Safety and Its Importance}
Memory safety ensures that a program never reads from or writes to invalid
locations in memory.
Violations lead to buffer overflows, use‑after‑free errors, and other
\emph{undefined behaviours} that can be exploited by attackers.
Industry post‑mortems reveal that roughly 70\,\% of high‑severity
vulnerabilities in large C/C++ codebases stem from memory‑safety bugs
\cite{msrc2019survey,google2022androidReport}.
Consequently, governments and vendors now advocate
\emph{memory‑safe programming languages} that eliminate these classes of bugs
by design~\cite{whitehouse2024memo}.

Rust is a modern systems language that promises C‑like performance \emph{and}
strong, compile‑time memory‑safety guarantees.
This paper surveys the fundamentals of memory safety, examines Rust’s approach
in depth, and compares it with C/C++, Java, and Go.
We highlight real‑world deployments and the latest academic work that validate
Rust’s safety claims.

\section{Memory Safety Issues in C/C++}
C and C++ give developers manual control over allocation, de‑allocation, and
pointer arithmetic.
While this yields maximal flexibility, it also means the compiler
\emph{cannot} enforce spatial or temporal safety.
Listing~\ref{lst:cpp_df} illustrates a classic double‑free in C++.

\begin{lstlisting}[language=C++,caption={Double‑free in C++},label={lst:cpp_df}]
#include <cstdlib>
int main() {
    int* p = static_cast<int*>(std::malloc(sizeof(int)));
    *p = 42;
    int* q = p;
    std::free(p);
    std::free(q);          // undefined behaviour: double free
}
\end{lstlisting}

The program compiles but may crash or corrupt the heap at run‑time.
Static analysers or sanitizers can mitigate such bugs, yet they remain an
\emph{optional} and \emph{best‑effort} defence.

\section{Garbage‑Collected Languages: Java and Go}
Languages like Java and Go achieve memory safety through a tracing garbage
collector (GC) and run‑time checks.
The GC prevents temporal errors (e.g.\ use‑after‑free) by freeing objects only
when unreachable; array bounds are checked at run‑time to avoid spatial errors.
This model is easy to program but incurs GC pauses and additional memory
overhead, making Java/Go less suitable for hard real‑time or very constrained
systems.

\section{Rust’s Ownership and Borrowing Model}
Rust removes the GC yet still guarantees safety by shifting checking to
\emph{compile time}.

\subsection{Ownership}
Every value has a single owner.
When the owner goes out of scope, Rust inserts a deterministic
\texttt{drop} call, freeing the allocation exactly once.
Moving ownership invalidates the original handle, preventing double‑free and
use‑after‑free.

\subsection{Borrowing and Lifetimes}
Values can be \emph{borrowed}.
Immutable borrows (\texttt{\&T}) allow many readers; a mutable borrow
(\texttt{\&mut T}) grants one writer and excludes readers.
The \emph{borrow checker} proves at compile time that:
\begin{itemize}
    \item no dangling pointers exist (lifetimes),
    \item the aliasing rule (many readers \emph{or} one writer) is upheld,
    \item data races are impossible in safe code.
\end{itemize}

\begin{lstlisting}[language=Rust,caption={Ownership prevents double‑free},label={lst:rust_df}]
fn main() {
    let p = Box::new(42);
    let q = p;     // ownership moves; `p` is now invalid
    drop(q);       // memory freed once
    // drop(p);    // compile error: value moved
}
\end{lstlisting}

\subsection{Unsafe Blocks}
Rust permits escape hatches via the \texttt{unsafe} keyword for
FFI and low‑level manipulation.
Such code is explicit and audited; the vast majority of production
Rust (\(<\!5\%\)) remains safe~\cite{jung2018rustbelt}.

\section{Performance Comparison}
Figure~\ref{fig:perf} summarises median run‑time performance from
Bugden \& Alahmar’s benchmark suite~\cite{bugden2022study}.
Rust matches C/C++ speed while Java and Go pay a GC tax.

\begin{figure}[h]
    \centering
    % Placeholder -- replace with actual figure if desired
    \fbox{\parbox{0.8\linewidth}{\centering\large
        Performance chart goes here}}
    \caption{Normalised run‑time performance (lower is better).}
    \label{fig:perf}
\end{figure}

\section{Real‑World Deployments}
\begin{description}
    \item[Android (\textbf{Google})] Zero memory‑safety
    vulnerabilities have been reported in new Rust components since 2019,
    halving Android’s overall bug volume~\cite{google2022androidReport}.
    \item[Firefox Stylo (\textbf{Mozilla})] Re‑writing the CSS engine
    in Rust eliminated \(\sim\)74\,\% of prior C++ security bug classes
    while boosting performance~\cite{mozilla2017stylo}.
    \item[Firecracker (\textbf{AWS})] A micro‑VM monitor written in Rust
    boots VMs in 125\,ms and underpins AWS Lambda~\cite{aws2019firecracker}.
    \item[Windows and Linux Kernels] Both projects have accepted Rust
    subsystems or drivers to curb pervasive memory bugs~\cite{msrc2019survey}.
\end{description}

\section{Academic Validation}
Rust’s guarantees are not merely empirical.
The \emph{RustBelt} project gives a machine‑checked proof of
type‑soundness and memory safety for a realistic subset of Rust,
including user‑defined \texttt{unsafe} abstractions~\cite{jung2018rustbelt}.

\section{Discussion and Future Work}
Rust demonstrates that low‑level performance and strong safety
are not mutually exclusive.
Adoption hurdles—primarily the learning curve and ecosystem maturity—are
diminishing as tooling, libraries, and formal methods advance.
Long‑term, a migration from legacy C/C++ to memory‑safe languages is forecast
for critical infrastructure.

\section{Conclusion}
Memory‑unsafe code accounts for the majority of serious software
vulnerabilities.
Garbage‑collected languages address this but at a cost to control and
predictability.
Rust offers a third path: compile‑time proofs of safety plus C‑class
performance.
Empirical data and formal verification jointly confirm its
effectiveness.
For systems engineers and researchers alike, Rust represents a viable
foundation for secure, high‑performance software.

\newpage
\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{msrc2019survey}
Microsoft Security Response Center.
\newblock A survey of memory safety issues, 2019.

\bibitem{google2022androidReport}
Jeff Vander Stoep and others.
\newblock Memory safety in {Android} 13, Google Security Blog, 2022. 

\bibitem{whitehouse2024memo}
Office of the National Cyber Director.
\newblock Back to the Building Blocks: A Path Toward {Memory‑Safe} Software,
  2024.

\bibitem{jung2018rustbelt}
Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, and Derek Dreyer.
\newblock \emph{RustBelt: Securing the Foundations of the Rust Programming
  Language}.
\newblock POPL~2018.

\bibitem{bugden2022study}
David Bugden and Firas Alahmar.
\newblock Performance and safety comparison of six programming languages.
\newblock Journal of Systems \& Software, 2022.

\bibitem{aws2019firecracker}
Agache et~al.
\newblock Firecracker: Lightweight virtualization for serverless applications,
  NSDI~2019.

\bibitem{mozilla2017stylo}
Mozilla Engineering Blog.
\newblock Shaping up {Stylo}, 2017.

\end{thebibliography}

\end{document}
